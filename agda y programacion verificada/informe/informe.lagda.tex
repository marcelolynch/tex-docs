% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage{agda}
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
\usepackage[margin=1.4in]{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....

\usepackage{graphicx} % support the \includegraphics command and options
\usepackage{fancyvrb}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{bbm}
\usepackage[english,spanish,es-tabla]{babel} 
\usepackage[T1]{fontenc} 
\usepackage{textgreek}
\usepackage{natbib}

\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\title{Introducci√≥n a los tipos dependientes y a la programaci√≥n verificada en Agda}
\author{Marcelo Lynch - Instituto Tecnol√≥gico de Buenos Aires}
\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Introducci√≥n}
\subsection{Objetivos de este trabajo}
Este informe se entrega a modo de examen final para la materia \textit{Programaci√≥n funcional} del Instituto Tecnol√≥gico de Buenos Aires. Los objetivos de este trabajo son:
\begin{itemize}
    \item Dar una breve introducci√≥n a la verificaci√≥n de software y sus t√©cnicas.
    \item Dar una introducci√≥n al lenguaje de programaci√≥n y asistente de demostraciones \textit{Agda} y sus distintas formas de verificar programas.
    \item Introducir el paradigma de las \textit{proposiciones como tipos}, con su justificaci√≥n te√≥rica, y su papel en c√≥mo se realizan demostraciones en Agda.
    \item Describir el concepto de \textit{tipo dependiente} (ausente en Haskell pero central en Agda), qu√© rol juega en la teor√≠a de tipos y en Agda.
\end{itemize}

En lo que sigue se presume que el lector est√° familiarizado con el lenguaje de programaci√≥n Haskell.


\section{Programaci√≥n verificada.}
\subsection{Verificaci√≥n de software} 
En un mundo en el que el software comienza a permear toda la actividad humana, y las personas delegan cada vez m√°s responsabilidades a sistemas autom√°ticos, se vuelve cada vez m√°s importante garantizar que el software \textit{hace lo que queremos que haga}. Podemos encontrar sin esfuerzo varios ejemplos en los que un error de software o \textit{bug} podr√≠a directamente costar vidas humanas:

\begin{itemize}
    \item Avi√≥nica
    \item Controladores en centrales nucleares
    \item Software en equipamiento m√©dico (para un ejemplo notable consultar \cite{leveson1993investigation})
\end{itemize}

A√∫n cuando el \textit{bug} no resulte en la muerte de nadie, puede tener un impacto financiero alt√≠simo \cite{harrison2003formal}. 

En todo caso, es cada vez m√°s clara la importancia de que los programas y algoritmos sean \textit{correctos} de acuerdo a alguna \textit{especificaci√≥n}. Al mismo tiempo que se vuelven ubicuos, los sistemas de software se vuelven cada vez m√°s complejos, lo que implica que su correcta implementaci√≥n y ausencia de errores se vuelve no trivial. Esto lleva a la necesidad de desarrollar herramientas, t√©cnicas y teor√≠as que asistan al programador en esa tarea. Esta tarea se enmarca dentro de la rama de las ciencias de la computaci√≥n conocida como \textit{ingenier√≠a de software}, y el acto de confirmar esta correcci√≥n es la \textit{verificaci√≥n}. 


\subsection{T√©cnicas de verificaci√≥n}
A continuaci√≥n repasaremos brevemente distintas aproximaciones a la verificaci√≥n de software. No se pretende hacer un an√°lisis exhaustivo sino presentar el panorama a grandes rasgos para tener un marco de referencia para analizar c√≥mo se realiza esto en el mundo funcional y en particular en Agda. 

\subsubsection{Testing y revisi√≥n de pares}
En la pr√°ctica los m√©todos m√°s utilizados para verificar software son la revisi√≥n de pares y el testing. La \textit{revisi√≥n de pares} es simplemente la aceptaci√≥n de otro programador de que un c√≥digo es correcto.

El \textit{testing} es una forma de comprobar el comportamiento de un programa en tiempo de ejecuci√≥n. Una \textit{suite de tests} comprueba que la ejecuci√≥n de un programa, porci√≥n de programa o componente tiene el comportamiento adecuado ante ciertos escenarios (usualmente dados por entradas o \textit{inputs} al programa) establecidos por el programador. 

El \textit{testing} es √∫til para encontrar bugs y para comprobar que el comportamiento de un sistema se mantiene consistente en el tiempo (ante cambios), pero no \textit{demuestra} la correcci√≥n pues solo contempla una secci√≥n limitada de entradas. Naturalmente, la revisi√≥n por pares tiene la misma limitaci√≥n.

\subsubsection{An√°lisis est√°tico y din√°mico para encontrar bugs}
Adem√°s del \textit{testing} podemos encontrar otras t√©cnicas que no implican una demostraci√≥n de correcci√≥n pero que ayudan a encontrar errores. Estos m√©todos pueden basarse en analizar el c√≥digo est√°ticamente (sin ejecutarlo) o din√°micamente (ejecut√°ndolo con diversas entradas, como hacen los tests). No nos detendremos a describir estas t√©cnicas, pero podemos nombrar como ejemplos paradigm√°ticos a la \textit{ejecuci√≥n simb√≥lica} y al \textit{fuzzing}.

\subsubsection{Verificaci√≥n formal}
La necesidad de realmente \textit{demostrar la correcci√≥n} nos lleva a los llamados \textit{m√©todos formales}. Podemos describir a los m√©todos formales como ``la matem√°tica aplicada para modelar y analizar sistemas de software'' (\cite{baier2008principles}, cap. 1)

Esta verificaci√≥n se hace proveyendo una demostraci√≥n formal de un modelo matem√°tico del sistema. Es interesante notar que la correspondencia entre el modelo matem√°tico y el sistema real se presume por construcci√≥n: debe establecerse externamente (as√≠ como se provee una especificaci√≥n). 

Una aproximaci√≥n es el \textit{model checking}, donde se provee un modelo matem√°tico que puede explorarse exhaustivamente para verificar las propiedades. En general se intentan modelar y explorar los distintos estados del sistema y las transiciones entre estos estados. 

Otra aproximaci√≥n, que es la que m√°s nos interesa en este trabajo, es la \textit{verificaci√≥n deductiva}. Para utilizar estas t√©cnicas es preciso dotar al sistema de una sem√°ntica que pueda expresarse en f√≥rmulas l√≥gicas. Tambi√©n se expresan en este formato las especificaciones que debe seguir el sistema. Con esto se acude a \textit{demostradores de teoremas} intentando deducir la verdad de las f√≥rmulas de la especificaci√≥n a partir de la sem√°ntica del sistema. 

\subsection{Demostradores de teoremas}
Como ya mencionamos, la verificaci√≥n deductiva hace uso de herramientas para la demostraci√≥n de los teoremas. El nivel de automaticidad de estas herramientas nos deja categorizarlas en \textit{demostradores autom√°ticos}, \textit{asistentes de demostraciones} (o \textit{proof assistants}) y \textit{verificadores de demostraciones} (o \textit{proof verification tools}).

La diferencia est√° en el nivel de involucramiento del usuario en la demostraci√≥n: un demostrador autom√°tico, como indica el nombre, es completamente autom√°tico. Un asistente de demostraci√≥n, en cambio, requiere el ingreso de \textit{pistas} por parte del usuario: por esto tambi√©n se llaman \textit{asistentes interactivo}, pues incluyen una interfaz en la que el usuario gu√≠a de alguna manera la b√∫squeda de la demostraci√≥n. Se habla en estos casos de una ``colaboraci√≥n humano-m√°quina''. Entre los asistentes de demostraci√≥n notables encontramos a \textit{Coq}, \textit{Isabelle} y el propio Agda, que estudiaremos a continuaci√≥n. 

Finalmente, los verificadores simplemente verifican la correcci√≥n de una demostraci√≥n provista, y no realizan trabajo de deducci√≥n. 

\subsection{La verificaci√≥n en el mundo Haskell}
Existen herramientas para hacer testing de programas Haskell. HUnit \cite{HUnit}, inspirada en el framework de testing para Java JUnit, permite programar casos de test ad-hoc. QuickCheck es una herramienta de generaci√≥n autom√°tica de tests aleatorios dada una especificaci√≥n \cite{claessen2011quickcheck}.

La naturaleza funcional de Haskell lo hace un buen candidato para la verificaci√≥n deductiva: tiene una sem√°ntica denotacional bien definida, es apropiado para razonar ecuacionalmente y su biblioteca est√°ndar promueve el uso de estructuras matem√°ticas con propiedades algebraicas fuertes y establecidas. Sin embargo, los programadores Haskell suelen razonar informalmente sobre sus programas, haciendo usualmente demostraciones en papel \cite{DBLP:journals/corr/abs-1711-09286}. Las mayores dificultades de la verificaci√≥n de programas Haskell es su posibilidad de no-terminaci√≥n, y tambi√©n las porciones que incluyen efectos secundarios.

Aproximaciones a la verificaci√≥n formal incluyen herramientas como \texttt{hs-to-coq}, que permite traducir programas Haskell a programas en Coq preservando su sem√°ntica y sobre los que se puede razonar en esa herramienta \cite{DBLP:journals/corr/abs-1711-09286}, y Haskabelle, que hace lo propio, traduciendo Haskell a teor√≠as de Isabelle y tambi√©n programas de Isabelle a Haskell, con garant√≠as de correcci√≥n parcial respecto a la especificaci√≥n provista en Isabelle \cite{haftmann2010higher}.

Finalmente, avances en el propio lenguaje Haskell, en particular extensiones del lenguaje sobre el sistema de tipos, permiten expresar invariantes de los programas usando tipos \cite{lindley2014hasochism}. Volveremos a comentar esto sobre el final de este trabajo.


\section{Introducci√≥n a Agda}
En este trabajo estudiaremos el lenguaje de programaci√≥n \textit{Agda} como herramienta tanto para programar (es un lenguaje funcional) como para verificar esos programas (mediante su poderoso sistema de tipos).

La versi√≥n actual de Agda (\textit{Agda 2}) fue desarrollada mayormente por Ulf Norell para su tesis de doctorado (\cite{norell:thesis}), a partir de un proyecto existente de la Universidad Tecnol√≥gica Chalmers en Gotemburgo, Suecia. Chalmers tiene una larga historia de desarrollo de asistentes de demostraciones basadas en la teor√≠a de tipos de Martin-L√∂f (comenzando en la d√©cada del 80): Agda 2 constituye su √∫ltimo desarrollo en esta √°rea. Si bien constituye un asistente de demostraci√≥n, Agda tambi√©n pretende ser un lenguaje de programaci√≥n de prop√≥sito general (para programar en s√≠ mismo y no solo para demostrar).

La notaci√≥n de Agda esta muy inspirada en la de Haskell, y as√≠ el estilo de programaci√≥n es similar: la definici√≥n de tipos de datos se hace de forma an√°loga a Haskell, y la definici√≥n de funciones suele ser por \textit{pattern matching}. Sin embargo, la teor√≠a subyacente a Haskell es distinta a la de Agda: mientras que Haskell est√° basada en el \textit{System F} de Girard (lambda c√°lculo tipado con polimorfismo param√©trico), Agda es una extensi√≥n de la teor√≠a de tipos de Martin-L√∂f, donde el \textit{tipo dependiente} es el principal objeto te√≥rico, y se utilizan los tipos tanto para especificar como para programar \cite{nordstrom1990programming}. Otra particularidad que tienen los programas de Agda (a diferencia de Haskell) es que \textbf{siempre terminan}: no puedo definir funciones parciales (como en Haskell), o, lo que es lo mismo, toda funci√≥n es estricta. Esto es una propiedad deseable en un sistema de demostraci√≥n de teoremas (de lo contrario aparecen inconsistencias), pero nos hace perder expresividad: Agda no es un lenguaje Turing-completo. 

Antes de adentrarnos de lleno con las particularidades de Agda, entonces, revisaremos la teor√≠a que tiene detr√°s, qu√© justifican que podamos demostrar teoremas con el sistema de tipos.

\section{La teor√≠a de tipos de Martin-L√∂f}
Se llama \textit{teor√≠a de tipos} a una serie de sistemas formales que sirven como alternativa a la teor√≠a de conjuntos como fundamento formal de la matem√°tica. 

Los matem√°ticos y cient√≠ficos de la computaci√≥n trabajan siempre con \textit{construcciones}: objetos matem√°ticos y objetos computacionales. A√∫n si imagina el fundamento en teor√≠a de conjuntos, el cient√≠fico categoriza a los objetos con los que trabaja, asoci√°ndolos a un \textit{tipo}. Las teor√≠as de tipos hacen expl√≠cita esta asociaci√≥n, tratando a los distintos tipos como ``ciudadanos de primera clase''.  Un programador que conozca un lenguaje tipado est√° naturalmente familiarizado con este concepto: los sistemas de tipos en general se ven fundamentados en alguna teor√≠a de tipos.

La teor√≠a de tipos de Martin-L√∂f fue presentada por Per Martin-L√∂f \cite{martin1984intuitionistic} como un fundamento matem√°tico intuicionista (constructivista): por esto es tambi√©n conocida como \textit{teor√≠a de tipos intuicionista}. Los v√≠nculos de la teor√≠a con la l√≥gica constructivista se har√°n m√°s claros en la secci√≥n siguiente.

La descripci√≥n de la teor√≠a y sus elementos se hace a partir de \textit{juicios}, es decir afirmaciones en el lenguaje metal√≥gico, en lugar de definiciones. As√≠, por ejemplo, en lugar de \textit{definir} el concepto de tipo veremos en qu√© condiciones se puede decir (es decir, emitir un juicio, o ``explicar'') que algo \textit{es un tipo}.

\subsection{Tipos}
El concepto fundamental en la teor√≠a de tipos es, naturalmente, el de \textit{tipo}. Un tipo se explica diciendo cu√°ndo un objeto es de ese tipo y tambi√©n qu√© significa que dos objetos del tipo sean iguales. Es decir, podemos emitir el juicio ``$A$ es un tipo'' cuando conocemos las condiciones de pertenencia al tipo y adem√°s una relaci√≥n de equivalencia que signifique la igualdad de objetos del tipo.

La pertenencia de un objeto $a$ al tipo $A$ se nota $a \in A$ o $a : A$.

Decimos que dos tipos $A$ y $B$ son iguales cuando todos los objetos id√©nticos de $A$ son objetos id√©nticos en $B$ y viceversa. 

Decimos que $B$ es una \textit{familia de tipos} indexada por $A$ si $B$ es una asignaci√≥n que para cada $a \in A$ asigna un tipo $B(a)$. 

\subsection{T√©rminos y objetos}
Describiendo a los tipos nombramos a los \textit{objetos} que tienen ese tipo. En rigor la metal√≥gica de la teor√≠a de tipos habla de \textit{t√©rminos}. As√≠, podemos considerar a $2 + 2$ y $4$ como dos t√©rminos distintos del tipo $\mathbb{N}$, que adem√°s son iguales en $\mathbb{N}$. Existe una noci√≥n de c√≥mputo integrada a a la teor√≠a que permite identificar a estos dos t√©rminos en $\mathbb{N}$, pues con las reglas de este c√≥mputo podemos reducir $2 + 2$ a $4$ (decimos que $2 + 2$ reduce a $4$): podr√≠amos pensar que los dos t√©rminos, refieren al mismo objeto (el ``cuatro''), o bien, considerando la noci√≥n de c√≥mputo y reducciones, que reducen a una misma forma can√≥nica (4): este concepto de igualdad se llama \textit{igualdad definicional} y se establece a nivel metate√≥rico (al nivel de los juicios sobre la teor√≠a).

Como este trabajo no pretende ser riguroso en la metateor√≠a sino solo presentar a nivel intuitivo la teor√≠a de tipos, en esta secci√≥n hablaremos indistintamente de ``objetos'', pero valdr√° la pena tener esto en cuenta m√°s adelante cuando hablemos de la igualdad en Agda (y volveremos al ejemplo de $2 + 2$ y $4$) as√≠ que lo mencionamos aqu√≠.

\subsection{El tipo \textit{\textbf{Set}}}
$\bm{Set}$ es un tipo. En la teor√≠a cl√°sica de Martin-L√∂f sus elementos son conjuntos definidos inductivamente. Dos elementos de $\bm{Set}$ son iguales si tienen los mismos elementos (como conjuntos). En Agda, el tipo \textit{\textbf{Set}} es un tipo que contiene a los dem√°s tipos, lo que en la teor√≠a de Martin-L√∂f podr√≠a llamarse el tipo \textit{\textbf{Type}}. En adelante usaremos la noci√≥n de Agda.

%\subsection{Universos}
%El tipo $\bm{Set}$ es un objeto matem√°tico en s√≠ mismo: ¬øhabita un tipo? Podr√≠amos estar tentados a decir que $\bm{Set} : \bm{Set}$, pero esto lleva a inconsistencias en el sistema (no podemos decir que la clase de todos los conjuntos es un conjunto). 

%Una forma de arreglar esto, que es la que adopta la teor√≠a de Martin-L√∂f, es considerar una cantidad infinita de \textit{universos} $\bm{Set_1}$ , $\bm{Set_2}$, $\dots$  tales que $\bm{Set} : \bm{Set_1}$, $\bm{Set_1} : \bm{Set_2}$, y as√≠ sucesivamente. Veremos m√°s adelante que en Agda todos los tipos son elementos de alg√∫n $\bm{Set_{\ell}}$

\subsection{Construyendo nuevos tipos}
La construcci√≥n de nuevos \textit{tipos de datos} a partir de otros ya existentes es ubicua en computaci√≥n: la teor√≠a de tipos tiene reglas ``constructivas'' donde dado tipos existentes podemos construir otros nuevos. A continuaci√≥n, algunos ejemplos de tipos que pueden construirse dentro de esta teor√≠a:

%\subsubsection{El tipo $El(A)$}
%Si $A ‚àà \textbf{Set}$, $El(A)$ es el tipo que tiene como %elementos a los elementos del conjunto $A$. En general %omitimos la aplicaci√≥n de $El$ y decimos ``$A$'' cuando %es claro que estamos hablando del tipo y no del elemento %de $\textbf{Set}$. 

\subsubsection{Tipos funcionales}
Si $A$ y $B$ son tipos podemos introducir el tipo $A \rightarrow B$, el espacio de funciones de $A$ a $B$. Un elemento $f \in A \rightarrow B$ se puede \textit{aplicar} a cualquier $a \in A$, y tenemos $f(b) \in B$.

\subsubsection{Pares ordenados}
Si $A$ y $B$ son tipos podemos introducir el tipo $A \times B$ de pares ordenados: la primera componente tiene elementos de $A$ y la segunda elementos de $B$. Los tipos de pares ordenados vienen equipados con proyecciones \[ \pi_1 : A \times B ‚Üí A \] \[\pi_2 : A \times B ‚Üí B \] tales que $\pi_1 ((a,b)) = a$ y $\pi_2 ((a,b)) = b$.

\subsubsection{El tipo suma}
Si $A$ y $B$ son tipos podemos introducir el tipo $A + B$, la suma disjunta de $A$ y $B$. Un elemento de este tipo ser√° o bien un elemento de $A$ o uno de $B$, junto con una indicaci√≥n de si provino de $A$ o de $B$\footnote{Pensando en conjuntos, el tipo A + B podr√≠a ser $A \times \{0\} \cup B \times \{1\}$: la segunda componente indica el ``origen'' del valor. En Haskell existe algo an√°logo en la forma del tipo \texttt{Either a b = Left a | Right b}, donde podemos saber el ``origen'' por pattern matching en los constructores \texttt{Left} y \texttt{Right}}. 

\subsection{Tipos dependientes}
Una herramienta poderosa de esta teor√≠a de tipos (y del sistema de tipos de Agda y otros lenguajes basados en este tipo de teor√≠as) son los \textit{tipos dependientes}, en los que la definici√≥n dependen de un \textit{valor}. 

\subsubsection{Tipos Œ†: funciones dependientes}
Si $B$ es una familia de tipos sobre $A$, existe el llamado producto dependiente, tipo de funciones dependientes o \textit{tipo pi}:
\[ \prod_{a\in A}B(a)
    \]

Este tipo contiene funciones con dominio (o entrada) en $A$ pero cuyo codominio (o tipo de salida) depende del valor en la que se aplica la funci√≥n. 

Por ejemplo: si llamamos $VecN(n)$ al conjunto de listas de $n$ elementos naturales, podemos considerar una funci√≥n $f$ que aplicada en un numero natural $n$ resulta en una lista de $n$ ceros. As√≠: 
\[
  f \in \prod_{n \in \mathbb{N}} VecN(n)
\]

Notemos que cuando $B$ es una asignaci√≥n constante, este tipo corresponde al tipo de funciones $A \rightarrow B$ antes mencionado (donde el codominio no depende del valor de entrada).


\subsubsection{Tipos $\Sigma$: pares dependientes}
Los elementos de los tipos $\Sigma$ son pares ordenados donde el tipo de la segunda componente depende del valor en la primera componente. Esto es, si $B$ es una familia de tipos sobre $A$, existe el tipo de pares dependientes, o \textit{tipo sigma} \[ \sum_{a \in A} B(a) \].

Cuando $B$ es una asignaci√≥n constante, este tipo corresponde al tipo de pares ordenados $A \times B$.

\subsubsection{El tipo igualdad}
Dados dos t√©rminos $x$, $y$ puede construirse el tipo igualdad $x \equiv y$. 

Existe un √∫nico constructor \texttt{refl} para cada tipo $A$ que dado un objeto de $A$ devuelve un valor de $a \equiv a$:

\[
  \texttt{refl} \in \prod_{a \in A} a \equiv a
\]

Notemos que $\texttt{refl}$ es la √∫nica forma de construir un valor del tipo igualdad: esto significa que si bien podemos hablar de un tipo $x \equiv y$ para cualesquiera dos t√©rminos $x$, $y$, el tipo $x ‚â° y$ solo estar√° habitado si $x$ es igual a $y$.

¬øPara qu√© querr√≠amos un tipo que represente la igualdad de un valor consigo mismo? Para entender esto, y c√≥mo utilizamos esta teor√≠a de tipos para demostrar teoremas, debemos explorar un resultado central, el isomorfismo de Curry-Howard, que establece un paralelismo entre los tipos de la teor√≠a de tipos y las proposiciones de la l√≥gica.

\section{Proposiciones como tipos}
\subsection{L√≥gica intuicionista}
La l√≥gica tiene distintas versiones: entre las varias distinciones podemos reconocer una diferencia entre la \textit{l√≥gica cl√°sica} y la \textit{l√≥gica intuicionista}. En la l√≥gica cl√°sica vale el principio del tercero excluido: ``o bien $A$ es verdadero, o bien $A$ es falso''. Esto nos deja por ejemplo demostrar $A \vee B$ con un argumento como el que sigue:

\begin{quotation}
``$A$ es o bien verdadero o falso (por tercero excluido). Si $A$ es falso, entonces $B$ es verdadero. Entonces $A ‚à® B$ es verdadero''
\end{quotation}

La l√≥gica intuicionista rechaza el principio del tercero excluido y con ello este tipo de argumentos: exige una demostraci√≥n concreta o bien de que $A$ es verdadero o de que $B$ es verdadero para concluir que $A \vee B$ es verdadero: en otras palabras, con la demostraci√≥n de $A ‚à® B$ debemos saber \textit{cu√°l de los dos vale}. La l√≥gica intuicionista es \textit{constructivista}: para demostrar la existencia de un elemento que satisface una propiedad hay que construirlo, exhibirlo.

\subsection{La correspondencia de Curry-Howard}
El concepto de \textit{proposiciones como tipos}, o \textit{correspondencia de Curry-Howard} es la relaci√≥n directa que existe entre las f√≥rmulas de la l√≥gica (proposiciones) con los tipos en la teor√≠a de tipos. La correspondencia es m√°s profunda que una mera biyecci√≥n entre f√≥rmulas y tipos sino un verdadero isomorfismo: tambi√©n vincula la noci√≥n de \textit{demostraci√≥n} con la de un \textit{programa}: as√≠, dar un programa de cierto tipo (o lo que es lo mismo, presentar un valor de ese tipo) equivale a demostrar una proposici√≥n.
\begin{table}[ht]
    \centering
    \begin{tabular}{|c|c|}
    \hline
    \textit{\textbf{L√≥gica}} & \textit{\textbf{Teor√≠a de tipos}} \\ \hline
    Proposici√≥n, f√≥rmula     & Tipo                              \\ \hline
    Demostraci√≥n             & Programa                          \\ \hline
    Evidencia                & Habitante de un tipo              \\ \hline
    \end{tabular}
    \caption{Correspondencia de Curry-Howard}
    \label{tab:cwi}
    \end{table}

La tabla \ref{tab:cwi} resume la correspondencia. La √∫ltima fila de la tabla es otra forma de decir que las f√≥rmulas verdaderas van a corresponder a tipos habitados (no vac√≠os), mientras que una f√≥rmula falsa se asocia a un tipo sin elementos. En la pr√°ctica dar un programa de un tipo es lo mismo que dar el habitante del tipo, luego usaremos ``evidencia'' y ``demostraci√≥n'' de manera intercambiable.

Aqu√≠ ya vemos como la correspondencia se da en el marco de la l√≥gica intuicionista (y de hecho la teor√≠a de Martin-L√∂f, como ya mencionamos, surge como una formalizaci√≥n intuicionista): la \textit{evidencia} la da un habitante concreto: una demostraci√≥n se da con un \textit{programa}, una verdadera construcci√≥n de la evidencia (el programa retorna un habitante de un tipo, es decir, demuestra la proposici√≥n que corresponde a ese tipo). 

\subsection{F√≥rmulas y tipos}
\subsubsection*{$A \land B$ corresponde a $A \times B:$}
En efecto, dar una demostraci√≥n de $A \land B$ es dar una demostraci√≥n de $A$ y una de $B$: dar un elemento del producto cartesiano $A \times B$ significa dar un elemento de $A$ y uno de $B$ (en el par ordenado), es decir una demostraci√≥n de $A$ (pensado como proposici√≥n) y una de $B$.

\subsubsection*{$A \vee B$ corresponde a $A + B$}
Como ya mencionamos en la discusi√≥n de l√≥gica cl√°sica versus intuicionista, para demostrar $A \vee B$ debemos proveer expl√≠citamente una demostraci√≥n de $A$ o una de $B$, indicando cu√°l se est√° demostrando. Dar un elemento del tipo suma de $A$ y $B$ es precisamente esto: un elemento de $A$ o uno de $B$ con la ``indicaci√≥n'' de cu√°l de los dos tipos tiene a ese elemento. 

\subsubsection*{$A \Rightarrow B$ corresponde a $A \rightarrow B$}
Una demostraci√≥n de la implicaci√≥n $A \Rightarrow B$ consiste en un procedimiento que dada una demostraci√≥n de $A$ obtiene una demostraci√≥n de $B$. Similarmente, un valor del tipo $A \rightarrow B$ es una funci√≥n, que aplicada a un valor de $A$ (es decir, una demostraci√≥n de $A$) devuelve un valor de tipo $B$ (es decir, una demostraci√≥n de $B$).

\subsubsection*{$‚àÄx:A.\ B(x)$ corresponde a $\prod_{x\in A} B(x)$}

Contar con una demostraci√≥n constructivista de $‚àÄx:A.\ B(x)$ implica que para cualquier $x : A$ podemos construir una demostraci√≥n de la proposici√≥n $B(x)$. Precisamente, un elemento del tipo $\prod_{x\in A} B(x)$ es una funci√≥n dependiente que para cada $x : A$ devuelve un elemento (demostraci√≥n) de $B(x)$.

\subsubsection*{$\exists x:A.\ B(x)$ corresponde a $\sum_{x\in A} B(x)$}


Contar con una demostraci√≥n constructivista de $‚àÉ x:A .\ B(x)$ implica que podemos mostrar un $x : A$ junto con la demostraci√≥n de que $B(x)$. Precisamente, mostrar un elemento del tipo $\sum_{x\in A} B(x)$ es mostrar un par ordenado con un elemento $x : A$ en la primera componente y un elemento de $B(x)$ en la segunda, es decir, la demostraci√≥n de $B(x)$.

\subsection{Conclusiones}
Hemos repasado la manera en la que corresponden los tipos y las proposiciones\footnote{Para una exposici√≥n m√°s extensa del tema, que profundiza sobre m√°s aspectos de la correspondencia y adem√°s incluye notas hist√≥ricas, referimos al lector al art√≠culo de Wadler \cite{wadler2015propositions}}. Tambi√©n vimos el papel fundamental que tienen los tipos dependientes en la expresividad de esta correspondencia: sin ellos no tendr√≠amos cuantificadores.

Con esto podemos regresar a la pregunta que nos hicimos al introducir el tipo igualdad: nos preguntamos all√≠ ``¬øpara qu√© lo queremos?'': una respuesta podr√≠a ser: ``no importa para qu√© lo queremos, el tipo $x \equiv x$ existe por existir la proposici√≥n \textit{x es igual a x}''. 

Sin embargo, ya estamos en condiciones de observar su utilidad: si podemos encontrar un elemento del tipo $x ‚â° y$, habremos demostrado que $x$ es igual a $y$. Podemos imaginar ahora c√≥mo se demuestran las propiedades de los programas en un lenguaje con tipos dependientes como Agda: \textbf{simplemente debemos exhibir un elemento que habite el tipo que corresponde a la proposici√≥n que queremos demostrar}. 

Es decir, para demostrar una propiedad como \[ \forall n,m : \mathbb{N} .\ n + m = m + n  \] basta con construir una funci√≥n del tipo \[ \prod_{n ‚àà \mathbb{N}}\prod_{m ‚àà \mathbb{N}} n + m ‚â° m + n \]

Habiendo introducido el fundamento te√≥rico que subyace a Agda y a sus demostraciones, podemos finalmente adentrarnos en el lenguaje y en c√≥mo \textit{programamos verificadamente} en la pr√°ctica. 

\section{Programando en Agda}
En las pr√≥ximas secciones escribiremos programas en Agda, enfoc√°ndonos en el aspecto de la verificaci√≥n utilizando el sistema de tipos. La idea de este informe es dar algunos ejemplos que nos dejen ver las distintas formas de verificar y nos permitan explicitar la correspondencia de Curry-Howard. Muchos de los ejemplos son tomados de los libros \cite{Stump16} y \cite{plfa2019}, que recomendamos como material para profundizar en el tema. 

Agda tiene soporte para chequear los tipos y agregarle \textit{syntax highlighting} a c√≥digo incrustado en documentos \LaTeX. Todo el c√≥digo que aparezca con colores a continuaci√≥n est√° chequeado por Agda antes de ser compilado como documento \LaTeX, es decir, podemos asegurar que son programas correctos.

\subsection{Nuestras primeras definiciones}
Comencemos nuestro camino en Agda definiendo dos tipos de datos, los booleanos y los naturales. 

\begin{code}
-- Definimos los booleanos
data ùîπ : Set where
    tt : ùîπ    -- true
    ff : ùîπ    -- false
        
-- Un tipo definido por inducci√≥n: los naturales
data ‚Ñï : Set where
    zero : ‚Ñï
    suc : ‚Ñï ‚Üí ‚Ñï

-- Un tipo polim√≥rfico: lista de A
data List (A : Set) : Set where
    [] : List A
    _::_ : A ‚Üí List A ‚Üí List A 
    
-- Pragmas 
{-# BUILTIN NATURAL ‚Ñï #-}
{-# BUILTIN LIST List #-}
\end{code}

Ya podemos notar varias particularidades del lenguaje a partir de estas definiciones.

\begin{itemize}
    \item En primer lugar, vemos que los tipos ‚Ñï y ùîπ se declaran a su vez como objetos del tipo \texttt{Set}. En Agda toda expresi√≥n tiene un tipo, y los propios tipos son valores. y podemos tener luego funciones que tomen elementos de \texttt{Set} que podr√≠an aplicarse con ‚Ñï o ùîπ.
    
    \item Los tipos de datos se definen mediante uno o m√°s \textit{constructores}. El estilo es similar al de Haskell, aunque se hace m√°s expl√≠cito que los constructores definen valores concretos del tipo (como \texttt{tt}, \texttt{ff} o \texttt{zero}) o son funciones que construyen un elemento (como \texttt{suc}). Vemos con ‚Ñï una definici√≥n de \textit{tipo inductivo}, donde el constructor \texttt{suc} recibe como argumento a un elemento de ‚Ñï para construir un elemento de ‚Ñï. 
    
    En Haskell las definiciones an√°logas ser√≠an \texttt{data Bool = Tt | Ff} y \texttt{data Nat = Zero | Suc Nat }

    \item Tenemos una idea similar a tipos polim√≥rficos. En este caso decimos que el tipo List est√° parametrizado por (A : Set). Podr√≠an aparecer muchos par√°metros, antes de los dos puntos que definen el tipo del tipo (en este caso el tipo de List A ser√° \verb|Set|). La definici√≥n es luego an√°loga a la que har√≠amos en Haskell.
    
    \item La l√≠nea \texttt{\{-\# BUILTIN NATURAL ‚Ñï \#-\}} es un \textit{pragma}, una directiva al compilador de Agda. En este caso le estamos indicando que identifique a nuestro tipo ‚Ñï con una noci√≥n interna de los n√∫meros naturales. Con esto podremos utilizar numerales para referirnos a los mismos: es decir escribir \texttt{0} ser√° lo mismo que escribir \texttt{zero}, \texttt{2} lo mismo que \texttt{suc suc 0}, etc√©tera.
\end{itemize}

\subsection{Definiendo funciones}
Definamos algunas funciones sobre los tipos de datos que tenemos hasta ahora 
\begin{code}
-- And booleano
_&&_ : ùîπ ‚Üí ùîπ ‚Üí ùîπ
tt && b = b
ff && _ = ff

-- Suma de naturales
_+_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
zero + n = n
suc m + n = suc (m + n)

if_then_else_ : {A : Set} ‚Üí ùîπ ‚Üí A ‚Üí A ‚Üí A
if tt then a else _ = a
if ff then _ else a = a

-- Declaramos asociatividad
-- y nivel de de precedencia (igual que Haskell)
infixr 9 _+_  
infixr 10 _&&_
\end{code}

Estas funciones simples nos dejan comentar m√°s particularidades del lenguaje:

\begin{itemize}
    \item Las funciones se definen por pattern matching, de manera muy similar a Haskell. Una diferencia a comentar es que a Agda le importan los espacios, es decir \verb|tt && ff| no es lo mismo que \verb|tt&&ff|. Esto es porque los identificadores pueden tener (casi) cualquier caracter Unicode (como venimos observando), y \verb|tt&&ff| se interpreta aqu√≠ como otro identificador.
    \item Las funciones pueden ser infijas, como \verb|_&&_|, pero tambi√©n \textit{mixfijas}, en donde los argumentos pueden intercalarse en posiciones arbitrarias, como muestra \verb|if_then_else_|: las posiciones de los argumentos se marcan con guiones bajos.
    \item Existe la aplicaci√≥n parcial manteniendo los guiones bajos donde falta aplicar: por ejemplo \verb|(if_then_else_) tt 3| es lo mismo que \verb|(if tt then 3 else_)| y tiene tipo ‚Ñï ‚Üí ‚Ñï, as√≠ como \verb|if tt then_else 2|.
    \item La definici√≥n de \verb|if_then_else_| muestra el uso de un \textit{par√°metro impl√≠cito}, que se escribe entre llaves (en este caso \verb|{A : Set}|). Esto nos, en este caso, expresar el polimorfismo de \verb|if_then_else_|: el tipo se inferir√° autom√°ticamente al ser aplicada, y no hace falta dar el par√°metro expl√≠citamente. De todas formas puede explicitarse aplic√°ndola con el argumento entre llaves: as√≠ \verb|(if_then_else_) {‚Ñï}| tiene tipo \verb|ùîπ ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï|.
\end{itemize}

\subsection{Nuestros primeros tipos dependientes}
Mostremos c√≥mo puede definirse un tipo dependiente en Agda. El ejemplo can√≥nico de tipo dependiente es el de vector: un vector es una lista de tama√±o fijo, donde el tama√±o es un n√∫mero natural. As√≠, el tipo depende de un valor de ‚Ñï. 

Consideremos para empezar una definici√≥n de vectores que solo admite vectores de tama√±o 0, 1, o 2:

\begin{code}
data Vec012 (A : Set) : (n : ‚Ñï) ‚Üí Set where
  v012[] : Vec012 A 0
  v012[_] : A ‚Üí Vec012 A 1
  v012[_,_] : A ‚Üí A ‚Üí Vec012 A 2
\end{code}

Hay bastante para decir aqu√≠: primero, podemos notar que el tipo \verb|Vec012| est√° parametrizado por $A$, como vimos en el caso de las listas. Sin embargo, el tipo de \verb|Vec012 A| es ahora \verb|‚Ñï ‚Üí Set|, es decir podemos aplicarlo en un n√∫mero natural \verb|n| para obtener finalmente el tipo dependiente \verb|Vec012 A n|. Se dice aqu√≠ que \verb|n| es un \textit{√≠ndice} del tipo. 

La diferencia entre un par√°metro como \verb|A| y un √≠ndice como \verb|n| es que todos los constructores comparten el par√°metro, mientras que el √≠ndice puede variar entre constructores. Notemos que todos los constructores usan el mismo \verb|A|, sin embargo cambian en el √≠ndice. ¬°La forma del √≠ndice afecta los habitantes del tipo! Notemos que los elementos de \verb|Vec012 A 0| son muy distintos a los de \verb|Vec012 A 1|, y ¬°los \verb|Vec012 A n| con \verb|n| mayor a dos ni siquiera tienen habitantes, pues no hay forma de construirlos!


¬øC√≥mo extendemos esto a vectores de cualquier longitud? Una definici√≥n podr√≠a hacerse as√≠:

\begin{code}
data ùïç (A : Set) : ‚Ñï ‚Üí Set where
  [] : ùïç A 0
  _::_ : ‚àÄ {n : ‚Ñï} (x : A) (xs : ùïç A n) ‚Üí ùïç A (suc n)
\end{code}

Hace su primera aparici√≥n en esta definici√≥n el s√≠mbolo ‚àÄ. Lo utilizamos para indicar que el constructor \verb|_::_| puede aplicarse a \textit{cualquier} \verb|x| del tipo \verb|A| y vector \verb|xs| de longitud \verb|n|, donde \verb|n| puede ser \textit{cualquier} natural (notemos que es un par√°metro impl√≠cito), para obtener un vector de longitud \verb|suc n|.

En rigor esta notaci√≥n es solamente \textit{syntax sugar}, y todas las siguientes ser√≠an equivalentes en su lugar:

\begin{verbatim}
    ‚àÄ {n : ‚Ñï} (x : A) (xs : ùïç A n) ‚Üí ùïç A (suc n)
    {n : ‚Ñï} (x : A) (xs : ùïç A n) ‚Üí ùïç A (suc n)
    ‚àÄ {n : ‚Ñï} ‚Üí A ‚Üí ùïç A n ‚Üí ùïç A (suc n)
    {n : ‚Ñï} ‚Üí A ‚Üí ùïç A n ‚Üí ùïç A (suc n)
\end{verbatim}

Adem√°s en este caso el compilador podr√≠a hasta inferir el tipo de \verb|n|, y podr√≠amos escribir alguna de:

\begin{verbatim}
    ‚àÄ {n : _} (x : A) (xs : ùïç A n) ‚Üí ùïç A (suc n)
    ‚àÄ {n} ‚Üí A ‚Üí ùïç A n ‚Üí ùïç A (suc n)
\end{verbatim}

en lugar de lo anterior.

\subsection{La igualdad}
En secciones anteriores vimos el tipo dependiente $x ‚â° y$, que corresponde a la proposici√≥n ``$x$ es igual a $y$'', con su constructor \texttt{refl} que dado un $x$ nos da un elemento de $x ‚â° x$. Una versi√≥n en Agda podr√≠a ser:

\begin{code}
data Eq (A : Set) (x : A) : A ‚Üí Set where
    refl : (Eq A x) x
\end{code}

Notemos que, como en el caso que vimos de \verb|Vec012|, no puedo habitar todos los tipos de la forma \verb|(Eq A x) y|: ¬°el √∫nico constructor que tenemos impone que el √≠ndice sea el mismo t√©rmino que el par√°metro! Es decir que s√≥lo estar√°n habitados los tipos \verb|Eq A x y| donde \verb|x| sea lo mismo que \verb|y|, como antes los √∫nicos \verb|Vec012 A n| que estaban habitados eran  \verb|Vec012 A 0, Vec012 A 1, Vec012 A 2|. Esto es lo que esperamos de un tipo que represente la igualdad, pues por la correspondencia de Curry-Howard encontrar un habitante del tipo es lo mismo que demostrar la proposici√≥n. 

%Hay dos cosas que se pueden mejorar para lograr una igualdad m√°s general:
%\begin{itemize}
%    \item Con esta definici√≥n estamos obligando al usuario a ser expl√≠citos en el tipo de \verb|x| (por ejemplo escribiendo \verb|Eq ‚Ñï 1 1| para el tipo que representa la proposici√≥n ``1 es igual a 1''). Esto podr√≠a estar impl√≠cito. 
%    \item Con esta definici√≥n no podr√≠amos expresar la proposici√≥n que dos tipos son iguales, por ejemplo ``ùîπ es igual a ùîπ''. Esto es porque el tipo de ùîπ es Set, pero no podemos escribir \verb|Set| en lugar de \verb|A| (es decir \verb|Eq Set ùîπ ùîπ|) porque \texttt{A : Set} y ¬°no es verdad que \texttt{Set : Set}!. 
%\end{itemize} 

Una definici√≥n m√°s general, que usaremos en adelante, hace impl√≠cito el par√°metro $A$, que puede inferirse:

% -- Importamos Agda.Primitive para acceder a 'Level'

\begin{code}
data _‚â°_ {A : Set} (x : A) : A ‚Üí Set where
    refl : x ‚â° x


-- Asociamos ‚â° a la noci√≥n interna de igualdad de Agda
{-# BUILTIN EQUALITY _‚â°_ #-}
infix 3 _‚â°_
\end{code}

Notemos que en la definici√≥n de \verb|refl| el \verb|x| de la izquierda define el \textit{par√°metro} y el de la derecha el \textit{√≠ndice} (ser√≠a lo mismo escribir \verb|(_‚â°_ x) x|, como pasaba con \verb|Eq| m√°s arriba).

\subsubsection{Igualdad definicional y proposicional}
Para los tipos \verb|_‚â°_| vale la misma observaci√≥n que hicimos con \verb|Eq|: los √∫nicos tipos igualdad que est√°n habitados son los de la forma \verb|x ‚â° x|, es decir solo encontraremos \textit{evidencia} de que \verb|x ‚â° y| si efectivamente son lo mismo. 

¬øQu√© quiere decir \textit{lo mismo} en este contexto? Nos estamos refiriendo al concepto de \textit{igualdad definicional} que ya describimos en la secci√≥n \textit{T√©rminos y objetos}. Mencionamos all√≠ que la igualdad definicional se establece como juicio a nivel metate√≥rico: en el caso de Agda, esto significa que Agda tiene una especie de ``tabla de juicios'' que establecen la igualdad definicional entre t√©rminos. Cada vez que definimos una funci√≥n, estamos agregando juicios a esta ``tabla''. 

Por ejemplo, si definimos la funci√≥n \verb|pred| as√≠:

\begin{code}
pred : ‚Ñï ‚Üí ‚Ñï
pred 0 = 0
pred (suc n) = n 
\end{code}

Le estamos diciendo a Agda que los t√©rminos \verb|pred (suc n)| y \verb|n| son \textit{definicionalmente iguales} (lo marcamos con el s√≠mbolo \verb|=|). Esto quiere decir que son completamente intercambiables: los dos t√©rminos reducen a alguna forma can√≥nica siguiendo alguna cadena de definiciones. 

Con este mismo criterio, los t√©rminos \verb|1 + 1|, \verb|pred 3|, y \verb|2| tambi√©n son definicionalmente iguales: siguiendo la definici√≥n de \verb|_+_| tenemos:

\verb|     1 + 1 = suc 0 + 1 = suc (0 + 1) = suc 1 = 2|

Y siguiendo la definici√≥n de \verb|pred|

\verb|    pred 3 = pred (suc 2) = 2|

Por otro lado tenemos la \textit{igualdad proposicional}, que es la igualdad expresada a trav√©s de una proposici√≥n: esto es lo que captura el tipo que llamamos \verb|_‚â°_|. A diferencia de la igualdad definicional, la igualdad proposicional (por ser una proposici√≥n), requiere una demostraci√≥n, o lo que es lo mismo, una evidencia en forma de un habitante del tipo.

\subsection{Nuestra primera demostraci√≥n}
La igualdad definicional implica la igualdad proposicional. Si sabemos que dos t√©rminos  \verb|t| y \verb|t'| son definicionalmente iguales, entonces sabemos que \verb|refl| podr√° construir un elemento de \verb|t ‚â° t'|. Tenemos entonces una demostraci√≥n ``gratis'' de la proposici√≥n. Basados en el ejemplo anterior, entonces, escribimos nuestra primera demostraci√≥n en Agda:

\begin{code}
1+1-es-2 : 1 + 1 ‚â° 2
1+1-es-2 = refl
\end{code}

Es importante entender que \verb|1+1-es-2| no solo es el t√≠tulo de la demostraci√≥n: es un habitante del tipo \verb|1 + 1 ‚â° 2|, \textit{es la demostraci√≥n} de esa proposici√≥n. Si en alguna demostraci√≥n posterior necesit√°ramos evidencia de esta proposici√≥n, basta con presentar el \textit{valor} \verb|1+1-es-2|. 

Es oportuno remarcar la consecuencia pr√°ctica de la correspondencia de Curry-Howard: como la demostraci√≥n de la proposici√≥n es simplemente un elemento del tipo correspondiente, con que nuestro programa pase el \textit{type checker} podemos estar seguros de que es correcta (aunque queda a cargo del programador, por supuesto, asegurarse de que el tipo que estamos utilizando realmente corresponde a la proposici√≥n que queremos demostrar).


\section{Demostrando propiedades de nuestros programas}
\subsection{Demostraciones universales}
Consideremos la funci√≥n \verb|~| de negaci√≥n booleana:

\begin{code}
-- Negaci√≥n
~_ : ùîπ ‚Üí ùîπ
~ tt = ff
~ ff = tt

infix 7 ~_
\end{code}

¬øQu√© tipo de propiedades podemos demostrar sobre esta funci√≥n? Algo muy natural que podr√≠amos desear probar es que negar dos veces es como no hacer nada.

Podr√≠amos demostrarlo por separado para cada constructor, sabiendo que por c√≥mo reducir√°n las expresiones por definici√≥n podemos usar \verb|refl|:

\begin{code}
-- Caso tt
~~-tt : ~ ~ tt ‚â° tt
~~-tt = refl

-- Caso ff
~~-ff : ~ ~ ff ‚â° ff
~~-ff = refl
\end{code}

Sin embargo, ser√≠a m√°s conveniente demostrar la propiedad universal: que \textit{para todo elemento b de ùîπ se cumple} \verb|~ ~ b ‚â° b|. Podemos expresar esta proposici√≥n con un cuantificador universal, y demostrarla por pattern matching de forma igual a como hicimos cada caso por separado:

\begin{code}
-- Demostrando un enunciado universalmente cuantificado
-- En este caso basta con enumerar todos los casos por pattern matching
~~-elim : ‚àÄ (b : ùîπ) ‚Üí ~ ~ b ‚â° b
~~-elim tt = refl
~~-elim ff = refl
\end{code}

Observemos que el tipo de \verb|~~-elim| \textbf{es una funci√≥n dependiente: dado el argumento} \verb|b : ùîπ| \textbf{devuelve un valor del tipo} \verb|~ ~ b ‚â° b|. Es exactamente el tipo dependiente que corresponde a una proposici√≥n con cuantificador universal que discutimos anteriormente. Su definici√≥n puede hacerse  entonces como cualquier funci√≥n. En este caso por pattern matching, en cada caso se reduce a \verb|refl| de la misma manera que cuando demostramos las proposiciones por separado. 


\subsection{Reutilizando demostraciones}
Consideremos la siguiente demostraci√≥n:

\begin{code}
~~&&' : ‚àÄ (b1 b2 : ùîπ) ‚Üí  (~ ~ b1) && b2 ‚â° b1 && b2
~~&&' tt b2 = refl
~~&&' ff b2 = refl
\end{code}

La idea de la demostraci√≥n es la misma que la anterior: cuando \verb|~ ~ b1| se concretiza a \verb|~ ~ tt| o \verb|~ ~ ff| por pattern matching, sabemos que reduce a \verb|tt| y a \verb|ff| respectivamente y podemos usar \verb|refl|. 

¬øPodemos reutilizar \verb|~~-elim| para no repetir este argumento en la demostraci√≥n? La respuesta es s√≠, utilizando la directiva \verb|rewrite|. Veamos como queda antes de explicarlo:

\begin{code}
~~&& : ‚àÄ (b1 b2 : ùîπ) ‚Üí  (~ ~ b1) && b2 ‚â° b1 && b2
~~&& b1 b2 rewrite (~~-elim b1) = refl
\end{code}    

¬øQu√© esta sucediendo aqu√≠? Sabemos que para definir \verb|~~&& b1 b2| debemos dar algo del tipo \verb|(~ ~ b1) && b2 ‚â° b1 && b2|. Al escribir \verb|rewrite p|, donde \verb|p| debe ser un elemento de tipo \verb|X ‚â° Y|, Agda sabe que puede reemplazar toda aparici√≥n de \verb|X| en el tipo que debemos lograr por \verb|Y|, porque \textbf{p es evidencia de que el t√©rmino} \verb|X| \textbf{es proposicionalmente igual que} \verb|Y|. Esto funciona solamente con los tipos \verb|_‚â°_|, porque oportunamente lo asociamos con la noci√≥n interna de igualdad proposicional de Agda mediante el pragma \verb|BUILTIN EQUALITY|. 

En nuestro caso, al aplicarlo con \verb|~~-elim b1|, que tiene tipo \verb|~ ~ b1 ‚â° b1|, ahora en lugar de dar evidencia de \verb|(~ ~ b1) && b2 ‚â° b1 && b2| debemos dar evidencia de \verb|b1 && b2 ‚â° b1 && b2|, pero ¬°estos t√©rminos son definicionalmente iguales! Luego la evidencia es \verb|refl|. 

Vemos con esto otra ventaja de que \verb|~~-elim| sea una demostraci√≥n universal: de otra forma no lo podr√≠amos haber aplicado a un \verb|b1| gen√©rico para hacer la reescritura.

\subsection{Demostraciones por inducci√≥n}
Para demostrar cosas sobre funciones de ùîπ podemos usar pattern matching exhaustivo sobre sus constructores, pero para demostrar proposiciones sobre tipos inductivos debemos usar argumentos inductivos. Consideremos la siguiente demostraci√≥n:

\begin{code}
+0 : ‚àÄ (a : ‚Ñï) ‚Üí a + 0 ‚â° a
+0 0 = refl
+0 (suc n) rewrite (+0 n) = refl
\end{code}

Recordemos que la definici√≥n de \verb|_+_| es inductiva en su primer argumento, luego \verb|a + 0 ‚â° a| no es trivialmente cierto por igualdad definicional (mientras que \verb|0 + a ‚â° a| s√≠ lo es).

La primera l√≠nea de la demostraci√≥n corresponde al caso base de la inducci√≥n: demostrar \verb|+0 0| es dar un elemento de \verb|0 + 0 ‚â° 0|. Estos dos t√©rminos son definicionalmente iguales, luego podemos dar evidencia con \verb|refl|.

En la segunda l√≠nea debemos demostrar \verb|+0 (suc n)|: esto es, dar un elemento de \verb|(suc n) + 0 ‚â° suc n|. Por definici√≥n de \verb|_+_|, \verb|(suc n) + 0 = suc (n + 0)|, luego basta con dar un elemento de \verb|suc (n + 0) ‚â° suc n|. 

Si pudi√©ramos ahora reemplazar \verb|n + 0| por \verb|n|, entonces terminar√≠amos con \verb|refl| (pues los t√©rminos ser√≠an definicionalmente iguales). Para eso debemos proveerle a rewrite evidencia de que \verb|n + 0 ‚â° n|. ¬°Pero eso es justamente lo que hace la funci√≥n que estamos definiendo! Podemos invocarla recursivamente sobre \verb|n| para obtener un elemento de \verb|n + 0 ‚â° n|, y es precisamente lo que hacemos. Esto corresponde al paso inductivo en una demostraci√≥n por inducci√≥n, donde invocamos la evidencia de la hip√≥tesis inductiva con el llamado recursivo.


\subsection{Demostraciones interactivas}
Para terminar, demostremos un par de propiedades m√°s. Comencemos por la simetr√≠a de \verb|_‚â°_|: la proposici√≥n de que si \verb|a ‚â° b| entonces \verb|b ‚â° a|.

\begin{code}
sym : ‚àÄ {A : Set} {a b : A} ‚Üí a ‚â° b ‚Üí b ‚â° a
sym refl = refl
\end{code}

El tipo que corresponde a una implicaci√≥n es una funci√≥n: \verb|sym| es entonces una funci√≥n que recibe evidencia de \verb|a ‚â° b| y devuelve evidencia de que \verb|b ‚â° a| (y los valores sobre los que depende, es decir las variables cuantificadas, se reciben impl√≠citamente).

La demostraci√≥n es muy sencilla: al hacer \textit{pattern matching} sobre \verb|refl|, que es el √∫nico constructor de un tipo \verb|a ‚â° b|, Agda puede darse cuenta de que \verb|a| y \verb|b| son definicionalmente iguales (pues de lo contrario ese tipo no podr√≠a ser construido por \verb|refl|), luego la evidencia de \verb|b ‚â° a| es simplemente \verb|refl|. 

Este hecho parece trivial a simple vista, pero es muy √∫til cuando queremos ``invertir el orden'' de dos t√©rminos asociados con \verb|_‚â°_| en un \verb|rewrite|. Veremos un ejemplo de su uso a continuaci√≥n.

Terminaremos esta secci√≥n ilustrando el car√°cter interactivo de Agda. Agda posee un plugin para el editor \textit{Emacs} (e instalaciones personalizadas de Emacs) que permiten utilizarlo interactivamente para realizar demostraciones de manera incremental.

Intentaremos demostrar la conmutatividad de la suma. La proposici√≥n que queremos demostrar es \verb|‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a|, y procedemos por inducci√≥n en la primera variable. Si en el editor de Agda escribimos los casos que tenemos que contemplar, pero con un \verb|?| en donde deben ir las definiciones:

\begin{verbatim}
    +comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
    +comm 0 b = ?
    +comm (suc n) b = ?    
\end{verbatim}

y luego tecleamos \verb|Control-x, Control-l|, veremos aparecer lo siguiente:

\begin{verbatim}
    +comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
    +comm 0 b = {}0
    +comm (suc n) b = {}1    
\end{verbatim}

En lugar de los signos de interrogaci√≥n aparecen lo que se llaman \textit{agujeros}. Adem√°s, Agda nos indica qu√© tenemos que llenar en los agujeros:

\begin{verbatim}
    ?0 : zero + b ‚â° b + zero
    ?1 : suc n + b ‚â° b + suc n        
\end{verbatim}

Esto nos ayuda a llenar cada agujero. En primer lugar, vemos que en el caso caso base debemos dar un valor del tipo \verb|0 + b ‚â° b + 0|. Esto  es definicionalmente igual a \verb|(b ‚â° b + 0)|, que es la proposici√≥n sim√©trica a la proposici√≥n \verb|(+0 b)|, que demostramos antes. Luego podemos lograr evidencia de eso con \verb|sym (+0 b)|. 

Llenando el agujero:

\begin{verbatim}
    +comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
    +comm 0 b = {sym (+0 b)}0
    +comm (suc n) b = {}1
\end{verbatim}

y tecleando \verb|Control-c, Control-r|, si lo que llenamos es correcto el agujero desaparece y nos queda el otro: 

\begin{verbatim}
    +comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
    +comm 0 b = sym (+0 b)
    +comm (suc n) b = {}0
\end{verbatim}

En este caso, deber√≠amos llenarlo con un valor de \verb|suc n + b ‚â° b + suc n|. Lo primero que podemos intentar es aplicar recursivamente:

\begin{verbatim}
    +comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
    +comm 0 b = sym (+0 a)
    +comm (suc n) b rewrite (+comm n b) = {}0
\end{verbatim}

Si volvemos a teclear \verb|Control-c, Control-l| Agda nos dice que ahora lo que tenemos que llenar en el agujero es un valor de:

\verb|    suc (b + n) ‚â° b + suc n|.

No es claro como podr√≠amos demostrar esto directamente aqu√≠, pero vemos que esto es una propiedad general de los naturales que podemos demostrar aparte como un lema. 
Para llegar a esta demostraci√≥n tambi√©n podemos hacer uso de los agujeros, pero omitimos esos pasos por brevedad. Obtenemos la demostraci√≥n:

\begin{code}
lem-suc : ‚àÄ (a b : ‚Ñï) ‚Üí suc (a + b) ‚â° a + suc b
lem-suc 0 b = refl
lem-suc (suc n) b rewrite lem-suc n b = refl
\end{code}


Finalmente, si lo aplicamos como un segundo rewrite (utilizando el s√≠mbolo | para separarlo del otro):

\begin{verbatim}
    +comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
    +comm 0 b = sym (+0 a)
    +comm (suc n) b rewrite (+comm n b) | (lem-suc b n) = {}1 
\end{verbatim}

Vemos que la pista del agujero es:

\verb|    b + suc n ‚â° b + suc n|

Estos t√©rminos son definicionalmente iguales, luego podemos llenar el agujero con \verb|refl|. Obtenemos la demostraci√≥n final:


\begin{code}
+comm : ‚àÄ (a b : ‚Ñï) ‚Üí a + b ‚â° b + a
+comm 0 b = sym (+0 b)
+comm (suc n) b rewrite (+comm n b) | (lem-suc b n) = refl   
\end{code}

\section{Verificaci√≥n interna}
Hasta ahora estuvimos tipos de datos (como ‚Ñï) y programas (como \verb|_+_|) y luego demostrando independientemente propiedades sobre los mismos. Esto podr√≠a llamarse \textit{verificaci√≥n externa}: las demostraciones son externas a los programas.

En contraste, podemos considerar un estilo de verificaci√≥n que podemos llamar \textit{verificaci√≥n interna}, en donde expresamos las proposiciones \textit{dentro de los mismos tipos de datos y programas}: la idea es escribir tipos y funciones m√°s expresivos: la correcci√≥n de las funciones y las invariantes de las estructuras de datos est√°n garantizadas por el propio tipo.
\newpage
\subsection{Vectores}

Ya hemos visto un ejemplo cuando definimos ùïç: los vectores tienen su longitud en el mismo tipo. Tener la longitud asociada nos permite expresar relaciones entre las longitudes de entradas y salidas de funciones sobre vectores.

Por ejemplo, si definimos la concatenaci√≥n de vectores y la funci√≥n \verb|headùïç| as√≠:

\begin{code}
-- Concatenaci√≥n de vectores
_++ùïç_ : ‚àÄ {A : Set} {n m : ‚Ñï} ‚Üí ùïç A n ‚Üí ùïç A m ‚Üí ùïç A (n + m)
[] ++ùïç ys = ys
(x :: xs) ++ùïç ys = x :: (xs ++ùïç ys) 
\end{code}

El simple hecho de que la funci√≥n compile (es decir, que pase por el \textit{type checker}) nos indica que, realmente, la longitud de la concatenaci√≥n es la suma de las longitudes de los vectores de entrada.

Para la concatenaci√≥n de listas, que se define de forma an√°loga:

\begin{code}
_++_ : ‚àÄ {A : Set} ‚Üí List A ‚Üí List A ‚Üí List A
[] ++ ys = ys
(x :: xs) ++ ys = x :: (xs ++ ys) 
\end{code}
    
La demostraci√≥n de esa propiedad habr√≠a que hacerla externamente, definiendo una funci√≥n de longitud y luego usando una estrategia como las que vimos en la secci√≥n anterior.


Estos tipos con informaci√≥n (como ùïç y su longitud) nos dejan definir funciones dependientes que no podr√≠amos de otra manera. Recordemos que en Agda toda funci√≥n debe terminar (toda funci√≥n es estricta), luego no es v√°lido definir la funci√≥n \verb|head| sobre listas de manera similar a Haskell

\begin{verbatim}
    -- Error: Esto no puede hacerse en Agda! 
    head : ‚àÄ {A : Set} ‚Üí List A ‚Üí A
    head (x :: xs) = x
\end{verbatim}

En cambio podemos utilizar la longitud asociada a los vectores para definir una version segura de \verb|head| para ellos:

\begin{code}
-- Extraer el primer elemento de vectores no vac√≠os
headùïç : ‚àÄ {A : Set} {n : ‚Ñï} ‚Üí ùïç A (suc n) ‚Üí A
headùïç (x :: xs) = x
\end{code}    

En efecto, \verb|headùïç| solo puede recibir vectores de longitud 1 o m√°s (\verb|suc n| para alg√∫n \verb|n| impl√≠cito).  

\subsection{√Årboles binarios de b√∫squeda}
El segundo y √∫ltimo ejemplo que consideraremos es el de un √°rbol binario de b√∫squeda con elementos naturales. Para definir el √°rbol binario debemos primero definir el orden entre los naturales. Lo haremos a trav√©s de una funci√≥n que devolver√° el booleano \verb|tt| cuando el primer argumento sea menor o igual al segundo:

\begin{code}
_‚â§_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ùîπ
zero ‚â§ zero = tt
zero ‚â§ (suc a) = tt
(suc b) ‚â§ zero = ff
(suc a) ‚â§ (suc b) = a ‚â§ b

infix 10 _‚â§_
\end{code}

Para expresar la invariante del √°rbol binario de b√∫squeda, a cada nodo le asociaremos una cota superior y una inferior, y garantizaremos que todos los valores del sub-√°rbol que tiene al nodo como ra√≠z est√©n entre las cotas. Finalmente, el √°rbol ser√° de b√∫squeda si el valor del nodo esta entre la cota superior del sub√°rbol izquierdo y la inferior del √°rbol derecho:

\begin{code}
-- √Årboles binarios de b√∫squeda con elementos naturales.
-- Indizados por dos elementos naturales, la cota inferior
-- y la superior de los elementos del √°rbol
data bst‚Ñï : ‚Ñï ‚Üí ‚Ñï ‚Üí Set where
    leaf : ‚àÄ {l u : ‚Ñï} ‚Üí l ‚â§ u ‚â° tt ‚Üí bst‚Ñï l u
    node : ‚àÄ {ll lr ul ur : ‚Ñï} 
                (elem : ‚Ñï) ‚Üí bst‚Ñï ll ul ‚Üí bst‚Ñï lr ur ‚Üí
                ul ‚â§ elem ‚â° tt ‚Üí elem ‚â§ lr ‚â° tt ‚Üí
                bst‚Ñï ll ur
\end{code}

Como se ve, los constructores requieren \textit{evidencia} de que las cotas son correctas. Para construir una hoja (vac√≠a) con cotas \verb|l, u| hay que proveer evidencia de que \verb|l| es menor o igual que \verb|u|. 

De la misma forma, para construir un √°rbol a partir de un elemento y dos sub√°rboles se usa el constructor \verb|node|. A ese constructor no solo se le pasa el elemento \verb|elem|, sino evidencia de que \verb|elem| se encuentra entre las cotas de los sub√°rboles, como explicamos antes. 

El √°rbol que se construye est√° acotado por la cota inferior del sub√°rbol izquierdo y la superior de la del sub√°rbol derecho.

Podemos construir paso a paso un √°rbol con un nodo con un 5 en la ra√≠z y un nodo con un 3 a la izquierda (y dem√°s hojas):

\begin{code}
-- Esta hoja estar√° a la izquierda de alg√∫n nodo
-- que tenga un elemento mayor o igual a 2
leaf1 : bst‚Ñï 0 2 
leaf1 = leaf refl

-- Esta hoja podr√° estar a la derecha de alg√∫n nodo
-- que tenga un elemento menor o igual a 4
-- o a la izquierda de alg√∫n nodo que tenga un
-- elemento mayor o igual a 5
leaf2 : bst‚Ñï 4 5
leaf2 = leaf refl

-- Esta hoja podr√° estar a la derecha de alg√∫n nodo
-- que tenga un elemento menor o igual a 6
-- o a la izquierda de alg√∫n nodo que tenga un
-- elemento mayor o igual a 7
leaf3 : bst‚Ñï 6 7
leaf3 = leaf refl


-- Las cotas de los nodos las determinan los sub√°rboles
-- (en este caso las hojas leaf1 y leaf2)
tree[*-3-*] : bst‚Ñï 0 5
tree[*-3-*] = node 3 leaf1 leaf2 refl refl


tree[[*-3-*]-5-*] : bst‚Ñï 0 7
tree[[*-3-*]-5-*] = node 5 tree[*-3-*] leaf3 refl refl


-- El √°rbol que construimos es:
--------[5]-------
------[3]--*------
-----*--*---------
-- Y las cotas son 0 (inferior) y 7 (superior)
\end{code}

\subsection{Conclusiones}
La verificaci√≥n interna tiene la ventaja de que obtenemos tipos de datos y operaciones muy ricos sem√°nticamente, con garant√≠as de integridad e invariantes expresadas dentro de las propias operaciones. 

La contracara es que es m√°s engorroso trabajar con ellos pues se deben garantizar las invariantes en cada operaci√≥n. Por ejemplo, para construir funci√≥n de inserci√≥n para \verb|bst‚Ñï| debemos garantizar que el resultado sea correcto, no importa el √°rbol ni el elemento que se inserte: no es para nada trivial escribir esta funci√≥n.

\section{Conclusiones finales}
La tendencia a construir software verificado no puede menos que aumentar en los pr√≥ximos a√±os. Nos hemos introducido en la teor√≠a de tipos de Martin-L√∂f y sus tipos dependientes como herramienta te√≥rica y pr√°ctica para lograr verificar nuestro software, sostenidos en la correspondencia de Curry-Howard y en un sistema de tipos potentes como el de Agda. 

El car√°cter interactivo de Agda y su nivel de expresividad lo hacen muy c√≥modo para la tarea, y nos permiten adoptar estilos de verificaci√≥n interna o externa seg√∫n la ocasi√≥n lo amerite. Esperamos haber convencido al lector de que vale la pena incursionar un poco en este mundo, a√∫n cuando este trabajo apenas toca la superficie de lo que es posible hacer con estas t√©cnicas. Nuevamente referimos a \cite{Stump16} y \cite{plfa2019} como lecturas muy completas sobre el lenguaje y sus capacidades que no presumen conocimiento previo.

La gran ventaja de las proposiciones como tipos y la verificaci√≥n dentro del mismo lenguaje de programaci√≥n han llevado a un gran inter√©s en tener tipos dependientes dentro del propio Haskell. Si bien existen dificultades al compatibilizar las caracter√≠sticas de Haskell que entran en conflicto con la teor√≠a de Martin-L√∂f y los tipos dependientes (en particular con efectos secundarios y no-terminaci√≥n), ya existen aproximaciones. La funcionalidad es todav√≠a incipiente y se basa en extensiones del lenguaje que hay que expl√≠citamente activar. 

Para trabajo te√≥rico al respecto referimos al lector a \cite{mcbride2002faking} y \cite{lindley2014hasochism}. Para un ejemplo ilustrativo se puede consultar \url{https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell}. 

Teniendo en cuenta que introducir verificaci√≥n a Haskell es una gran ventaja por su gran adopci√≥n en ambientes fuera de la academia como lenguaje de prop√≥sito general, otro proyecto interesante es \textbf{Idris} \cite{brady2013idris}, un lenguaje de programaci√≥n inspirado en Agda pero con todav√≠a mayores ambiciones que Agda de ser un lenguaje de prop√≥sito general y no tanto un asistente de demostraciones.

\bibliography{informe}{}
\bibliographystyle{alpha}
\end{document}
